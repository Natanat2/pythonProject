# # #3.6.1 Напишите цикл while, который находит максимальное натуральное число, квадрат которого меньше 1000.
# #
# # S = 1
# #
# # while S*S < 1000:
# #     S += 1
# #     print("Ещё считаю ...")
# #
# # print("Сумма равна: ", S-1)
#
# # ЗАДАНИЕ 3.7.2 (НА САМОПРОВЕРКУ) Попробуйте теперь самостоятельно подсчитать произведение всех чисел от 1 до N включительно.
# P = 1  # создаём переменную-счётчик, в которой мы будем считать произведение.
# #подумайте, чему она должна быть равна
# N = 5
#
# for i in range(1, N+1):
#     P *= i
# print(P)
#
# # ЗАДАНИЕ 3.7.3 (НА САМОПРОВЕРКУ)
# #
# # Напишите программу, которая будет печатать лесенку следующего типа:
# N = 4
# for i in range(1, N+1):
#     print('*'*i)
#
# ЗАДАНИЕ 3.8.1 (НА САМОПРОВЕРКУ) Напишите цикл, который ищет наибольший элемент в матрице.
# test_matrix = [[1, 2, 3],
#                [70, -1, 2],
#                [123, 2, -1]]
# max_value = 0
# for row in test_matrix:
#     for col in row:
#         if col > max_value:
#             max_value = col
# print(max_value)

# Итоговый проект Часть 2. Циклы
# Помните, в прошлом модуле мы с вами разбирали, как определить, содержит ли число цифры цифры, 5, 7 или 9:
# if ‘5’ in str(num):
# # ✍️ Ваша задача Напишите алгоритм, который делает то же самое, но работает только с числом, не приводя его в строку.
# # Для этого вам понадобится цикл while, операции деления на 10 и поиска остатка от деления на 10.
# # Вычисляя остаток от деления на 10, мы получаем крайнюю правую цифру числа, а деля число на 10 —
# # следующее число для итерации.
# num = 164863
# while num > 0:
#     num2 = num % 10
#     num = num//10
#     if num2 % 5 == 0 or num2 % 7 == 0 or num2 % 9 == 0:
#         print('Число содержит 5, 7 или 9')
#         break
# else:
#     print('В числе нет 5, 7 или 9')
# Задание 4.2.6
# Задание на самопроверку.
#
# Напишите функцию, которая проверяет, является ли данная строка палиндромом или нет,
# и возвращается результат проверки. Пример:
# def poly(text):
#     text = text.replace(' ','')
#     if text == text[::-1]:
#         print('Yes')
#     else:
#         print('No')
# poly('qw ere wq')

# Задание 4.3.2
# Задание на самопроверку.
#
# Написать функцию, которая будет перемножать любое количество переданных ей аргументов.
# def multy(*num):
#     sum = 1
#     for n in num:
#         sum *= n
#     return sum
# print(multy(4,5,6))

# Задание 4.3.3
# Задания на самопроверку.
#
# С помощью рекурсивной функции найдите сумму чисел от 1 до n.
# def sum(n):
#     if n == 1:
#         return 1
#     return n + sum(n-1)
#
# print(sum(5))

# Задание 4.3.4
# С помощью рекурсивной функции развернуть строку.
# def reverse_str(string):
#    if len(string) == 0:
#        return ''
#    else:
#        return string[-1] + reverse_str(string[:-1])
#
# reverse_str('test')  # tset

# Задание 4.3.5
# Дано натуральное число N. Вычислите сумму его цифр.
#
# При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется).
# def sum_digit(n):
#    if n < 10:
#        return n
#    else:
#        return n % 10 + sum_digit(n // 10)
#
# sum_digit(123)  # 6

# Задание 4.4.1
# Задание на самопроверку.
#
# Создать функцию-генератор, возвращающую бесконечную последовательность натуральных чисел.
# По умолчанию, она начинается с единицы и шагом 1, но пользователь может указать любой шаг и
# любое число в качестве аргумента функции, с которого будет начинаться последовательность.
#
# def gen(start=1, step=1):
#     n = start
#     while True:
#         yield n
#         n += step
# a = gen(1,5)
# print(next(a))
# print(next(a))

# Задание 4.4.2
# Задание на самопроверку.
#
# Создайте генератор, который по переданному списку создаёт последовательность, в которой элементы
# этого списка бесконечно циклично повторяются.
#
# Например, для списка [1, 2, 3] генератор создаст бесконечную последовательность 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, ... .
#
# def repeat_list(list_):
#    list_values = list_.copy()
#    while True:
#        value = list_values.pop(0)
#        list_values.append(value)
#        yield value
#
# for i in repeat_list([1, 2, 3]):
#    print(i)
#
# Задание 4.5.1
# Задание на самопроверку.
#
# Возьмите из предыдущего примера декорированные функции, которые возвращают время работы
# основной функции. Найдите среднее время выполнения для 100 выполнений каждой функции.
#
# import time
#
# N = 100
#
#
# def decorator_time(fn):
#    def wrapper():
#        t0 = time.time()
#        result = fn()
#        dt = time.time() - t0
#        return dt
#    return wrapper
#
#
# def pow_2():
#    return 10000000 ** 2
#
#
# def in_build_pow():
#    return pow(10000000, 2)
#
#
# pow_2 = decorator_time(pow_2)
# in_build_pow = decorator_time(in_build_pow)
#
# mean_pow_2 = 0
# mean_in_build_pow = 0
# for _ in range(N):
#    mean_pow_2 += pow_2()
#    mean_in_build_pow += in_build_pow()
#
# print(f"Функция {pow_2} выполнялась {N} раз. Среднее время: {mean_pow_2 / N:.10f}")
# print(f"Функция {in_build_pow} выполнялась {N} раз. Среднее время: {mean_in_build_pow / N:.10f}")
#
# Задание 4.5.2
# Задание на самопроверку.
#
# Напишите декоратор, который будет подсчитывать количество вызовов декорируемой функции.
# Для хранения переменной содержащей, количество вызовов, используйте nonlocal область декоратора.
#
# def decor(fun):
#     count = 0
#     def wrapper(*args, **kwargs):
#         nonlocal count
#         fun(*args, **kwargs)
#         count += 1
#         print(f'Функцию {fun} вызвали {count} раз')
#         return count
#     return wrapper
#
# @decor
# def prt(Hello):
#     print(Hello)
# for i in range(3):
#     prt('Hi')

#
# Задание 4.5.3
# Задание на самопроверку.
#
# Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции в словаре.
# Словарь должен находиться в nonlocal области в следующем формате: по ключу располагается аргумент
# функции, по значению результат работы функции, например, {n: f(n)}.
#
# def cache(func):
#    cache_dict = {}
#    def wrapper(num):
#        nonlocal cache_dict
#        if num not in cache_dict:
#            cache_dict[num] = func(num)
#            print(f"Добавление результата в кэш: {cache_dict[num]}")
#        else:
#            print(f"Возвращение результата из кэша: {cache_dict[num]}")
#        print(f"Кэш {cache_dict}")
#        return cache_dict[num]
#    return wrapper

# Задание 5.3.8
# Задание на самопроверку.
#
# Программа должна выводить «Обе переменные ложные», если они являются таковыми.
# Дополните условный оператор последним блоком.
# if a and b :
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print(a or b ) # печать одной переменной, которая является истинной
# else:
#     print("Обе переменные ложные")
#
# Задание 6.3.13
# Задание на самопроверку.
#
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
# tab = [[i*o for i in range(1,10)] for o in range(1,10)]
# print(tab)

# Задание 6.3.14
# Задание на самопроверку.
#
# Модифицируйте последний пример таким образом,
# чтобы в список сохранялось True, если элемент четный, и False, если элемент нечетный.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(L)

# Задание 6.3.17
# Задание на самопроверку.
#
# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
# a = [i for i in range(10)]
# b = [i for i in range(10,0,-1)]
# c = [aa*bb for aa,bb in zip(a,b)]
# print(c)

# Задание 6.3.18
# Задание на самопроверку.
#
# Реализуйте программу, которая сжимает последовательность символов. На вход подается последовательность вида:
#
# aaabbccccdaa
# Необходимо вывести строку, где каждая последовательность из одинаковых символов,
# идущих подряд, заменяется на один символ, и длину этой последовательности
# (включая последовательности единичной длины). Вывод должен выглядеть так:
#
# a3b2c4d1a2
#
# text = input()  # получаем строку
#
# last = text[0]  # сохраняем первый символ
# count = 0  # заводим счетчик
# result = ''  # и результирующую строку
#
# for c in text:
#     if c == last:  # если символ совпадает с сохраненным,
#         count += 1  # то увеличиваем счетчик
#     else:
#         result += last + str(count)  # иначе - записываем в результат
#         last = c  # и обновляем сохраненный символ с его счетчиком
#         count = 1
#
# result += last + str(count)  # и добавляем в результат последний символ
# print(result)

# Задание 5.4.9
# Задание на самопроверку.
#
# Напишите рекурсивную функцию, находящую минимальный элемент
# списка без использование циклов и встроенной функции min().
# def min_list(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])
#
# b = [1,2,4]
# a = min_list(b)
# print(a)

# Задание 5.4.10
# Задание на самопроверку.
#
# Напишите рекурсивную функцию, которая зеркально разворачивает число. Предполагается, что число не содержит нули.
#
# def razv(num):
#     a = str(num)
#     if len(a) == 1:
#         return a
#     else:
#         return a[-1] + razv(a[0:-1])
#
# def mirror(a, res=0):
#     return mirror(a // 10, res*10 + a % 10) if a else res
#
# a = 1234
# print(mirror(a))
#
# Задание 5.4.11
# Задание на самопроверку.
# Поработаем над более сложной рекурсивной функцией. Сейчас попробуем реализовать функцию equal(N, S),
# проверяющую, совпадает ли сумма цифр числа N с числом S. При написании программы следует обратить
# внимание на то, что, если S стала отрицательной, то необходимо сразу вернуть False.
# Реализуйте описанную выше функцию.
#
# def equal(N, S):
#     if S < 0:
#         return False
#     if N < 10:
#         return N == S
#     else:
#         return equal(N // 10, S - N % 10)
#
# Задание 5.4.15
# Задание на самопроверку.
#
# Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя.
# Все username пользователей хранятся в глобальной области видимости в списке USERS.
# При согласии пользователя на авторизацию ему предлагается ввести username, который также хранится
# в глобальной области видимости. Функция должна использовать два декоратора: один для проверки авторизации
# вообще (реализован выше), второй — для проверки доступа.
#
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
#
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь неавторизован. Функция выполнена не будет")
#     return wrapper
#
#
# @is_auth
# def from_db():
#     print("some data from database")
#
#
# from_db()
# USERS = ['admin', 'guest', 'director', 'root', 'superstar']
#
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
# if auth:
#     username = input("Введите ваш username:")
#
# @is_auth
# @has_access
# def from_db():
#     print("some data from database")
#
# from_db()
# Ответ
# def has_access(func):
#     def wrapper():
#         if username in USERS:
#             print("Авторизован как", username)
#             func()
#         else:
#             print("Доступ пользователю", username, "запрещен")
#     return wrapper